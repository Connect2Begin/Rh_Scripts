Пояснения к uniparse.lua и slnudata.odg

[uniparse.lua]

[— 1 —]
  Наконец, закончил работу над разбором алгоритма tcl‑скрипта
uniParse.tcl и реализовал его на Lua в файле uniparse.lua .
  Как я установил, используемый slnudata.c основан на UnicodeData.txt версии
примерно 3.1.0 (версии 3.0.1 и 3.2.0 не подходят из‑за существенных различий).
Слово "примерно" означает, что генерируемый lua‑скриптом файл slnudata.c
не совпадает с используемым. Как я выяснил, разница проявляется с U‑10400:
используемый файл ориентирован на то, что toupper‑символ для U-10400
расположен на позиции +0x2, тогда как по UnicodeData.txt для 3.1.0 выходит,
что он расположен на позиции +0x28.

  Чтобы подправить пути к исходному файлу UnicodeData.txt
и файлу‑результату slnudata.c, нужно в uniparse.lua задать
значения BasePath и DataPath и, м/б, названия файлов.
  Кроме того, можно подправить значение unit.NullLine, но это мало влияет
на конечный результат (добавляется информация о ещё некоторых кодовых точках).
  Для ограничения обрабатываемых кодовых точек есть закомментированный код.

  При разборе кода выяснил, что используется следующая информация:
  — кодовая точка,
  — категория,
  — преобразования: в верхний, нижний и заголовочный регистр.
  Категория символа сохраняется в полном объёме.
Но информация о преобразовании в заголовочный регистр теряется:
  1) если нет преобразования в верхний и нижний регистры
     (возможно, это недоработка),
  2) если есть преобразование в верхний регистр, не совпадающий
     с преобразованием в заголовочный регистр (это явная потеря), в этом случае
     сохраняется информация о преобразовании только в верхний регистр.
  Код обработки преобразований в функции unit.make_gitempart.

P.S. Кстати, в slndata.c, кажется, есть ограничение на codepoint до 0xFFFF
     включительно в #define GetUniCharInfo:
(((int)(ch)) & 0xffff)
  Аналогичное (явно указанное в комментарии) ограничение есть в slnunico.c:
#define charinfo(c) (~0xFFFF&(c) ? 0 : GetUniCharInfo(c)) /* BMP only */
  Насколько это ограничение серьёзно, ведь таблицы в slnudata.c хранят данные
о всех кодовых точках?

[— 2 —]
  lua‑скрипт, конечно, не один‑в‑один с tcl‑скриптом, но все tcl‑функции
и комментарии (только добавил перевод) есть в lua‑скрипте. Ну и, как всегда,
осталось много отладочных комментариев "DEBUG only".
  Надеюсь ещё — для большей наглядности — продумать и реализовать две схемы:
"Построение таблиц" + "Использование таблиц".

[— 3 —]

  Решил поиграть размером страниц.
Вот результаты по генерации файла при различных значениях unit.shift
для UnicodeData.txt версии 6.0.0:

shift	 Размер	 Длина	 Длина	  2^	Длина	Общий
		 файла	 pMap	 pages	shift	groups	размер
 1		2976501	 557056	  324	    2	 168	557704
 2		 653923	 278528	  548	    4	 168	280720
 3		 653923	 139264	  608	    8	 168	144128
 4		 355114	  69632	  521	   16	 168	 77968
 5		 220086	  34816	  422	   32	 168	 48320
 6		 163487	  17408	  293	   64	 168	 36160
 7		 139307	   8704	  175	  128	 168	 31104
 8		 139300	   4352	  108	  256	 168	 32000
 9		 161553	   2176	   69	  512	 168	 37504
10		 205286	   1088	   46	 1024	 168	 48192
11		 288607	    544	   33	 2048	 168	 68128
12		 443235	    272	   26	 4096	 168	106768
13		 714271	    136	   21	 8192	 168	172168
14		1087935	     68	   16	16384	 168	262212
15		1532759	     34	   11	32768	 168	360482
16		1924289	     17	    7	65536	 168	458769
17		1995908	      8	    4	 217	 168	524296

Общий размер = Длина pMap + Длина pages * 2^shift

  В большинстве случаев подходит значение в диапазоне 6–9, для версии
Unicode 6.0.0 лучшим значением будет shift = 7. Впрочем это можно было
ожидать, учитывая, что в Unicode под группы похожих символов обычно
выделяются блоки по 0x80 и 0x100 символов, а регулярность в группах
наблюдается по строкам 0x***0–0x***F.
  Для получения общей информации о результате нужно раскомментировать
блочный комментарий "-- Result information" в функции unit.main.

[slnudata.odg]
  Иллюстрация:
  Основной рисунок — получение информации о символе по кодовой точке символа.
Надписи со стрелками внизу — таблицы из uniparse.lua, по которым формируются 
структуры в slnudata.c .
   Пояснения:
   — из таблицы pMap получается один‑в‑один pageMap;
   — двумерная таблица pages разворачивается в одномерную groupMap;
   — glists из списков с информацией преобразуется в groups из чисел.

――――――――
